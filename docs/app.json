[{"name": "app.py", "content": "from shiny import App, reactive, render, ui\nimport json\nimport base64\nimport requests\nimport os\nfrom datetime import datetime, timezone\n\n\n# Define the list names\nLIST_NAMES = {\n    \"list1\": \"List 1\",\n    \"list2\": \"List 2\",\n    \"list3\": \"List 3\",\n    \"list4\": \"List 4\",\n    \"list5\": \"List 5\",\n    \"list6\": \"List 6\",\n    \"list7\": \"List 7\",\n    \"list8\": \"List 8\",\n    \"list9\": \"List 9\",\n    \"list10\": \"List 10\"\n}\n\napp_ui = ui.page_fillable(\n        ui.tags.style(\"\"\"\n        .draggable-task:hover {\n            background-color: #f8f9fa;\n        }\n        .droppable-list.drag-over {\n            border: 2px dashed #007bff !important;\n        }\n        .draggable-task {\n            transition: background-color 0.2s;\n        }\n        .droppable-list {\n            transition: border 0.2s;\n        }\n        .draggable-task {\n            cursor: move;\n            padding: 10px;\n            margin: 5px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        .droppable-list {\n            height: 100%;\n            min-height: 100px;\n            padding: 10px;\n            border: 1px dashed #ccc;\n            border-radius: 4px;\n        }\n        /* New styles for control panels */\n        .control-panel {\n            overflow: visible !important;\n            height: auto !important;\n            min-height: auto !important;\n        }\n        .control-panel .card-body {\n            overflow: visible !important;\n            padding: 15px;\n        }\n        .button-container {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 10px;\n            padding: 5px;\n        }\n        .move-controls {\n            display: flex;\n            align-items: center;\n            flex-wrap: wrap;\n            gap: 15px;\n        }\n    \"\"\"),\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.accordion(\n                ui.accordion_panel(\n                    \"Settings\",\n                    ui.output_text(\"online_status\"),\n                    ui.input_dark_mode(id=None, mode=\"dark\"),\n                    ui.input_switch(\"autosave_enabled\", \"Enable GitHub Auto-save\", value=True),\n                ),\n                id=\"settings_accordion\",\n                open=False\n            ),\n            \n            ui.input_text(\"task\", \"Enter Task\"),\n            ui.input_text_area(\"description\", \"Enter Description\", height=\"100px\"),\n            ui.input_action_button(\"add\", \"Add Task\", class_=\"btn-primary\"),\n            ui.output_text(\"unsaved_changes_alert\"),\n            ui.output_ui(\"manual_save_button\"),\n            ui.output_ui(\"task_selector\"),\n            \n            ui.input_action_button(\"load_github\", \"Load from GitHub\", class_=\"btn-info\"),\n            ui.input_text(\n                \"github_repo\",\n                \"Repository (user/repo)\",\n                value=\"\",\n                autocomplete=\"username/rep\"\n            ),\n            ui.input_password(\n                \"github_token\",\n                \"Github Token\",\n                value=\"\"\n            ),\n            ui.output_text(\"github_status_output\"),\n            \n            ui.input_action_button(\"edit_list_names\", \"Edit List Names\", class_=\"btn-secondary\"),\n            ui.output_ui(\"list_name_controls\"),\n            width=350\n        ),\n\n        # Main content starts here\n        ui.accordion(\n            ui.accordion_panel(\n                \"Working List (for adding/editing)\",\n                ui.input_radio_buttons(\n                    \"active_list\",\n                    \"\",\n                    LIST_NAMES,\n                    inline=True\n                ),\n            ),\n            open=True,\n            id=\"working_list_accordion\",\n        ),\n        \n        ui.div(\n        {\"style\": \"display: flex; flex-direction: column; gap: 10px; height: 100%;\"},\n        ui.div(\n            {\"style\": \"flex: 0 0 auto;\"},  # This div won't grow or shrink\n            ui.output_ui(\"edit_controls\"),\n            ui.output_ui(\"move_controls\"),\n            ui.output_ui(\"conflict_dialog\"),\n        ),\n        ui.div(\n            {\"style\": \"flex: 1 1 auto; min-height: 0;\"},  # This div will take remaining space\n            ui.card(\n                ui.accordion(\n                    ui.accordion_panel(\n                        \"Select Lists to Display\",\n                        ui.input_checkbox_group(\n                            \"display_lists\",\n                            \"\",\n                            LIST_NAMES,\n                            selected=[\"list1\"],\n                            inline=True\n                        )\n                    ),\n                    open=True,\n                    id=\"display_lists_accordion\"\n                ),\n                ui.input_switch(\"use_drag_drop\", \"Enable drag and drop view\", value=False),\n                ui.output_ui(\"task_lists_display\"),\n                full_screen=True\n            )\n        )\n    )\n    )\n)\n\ndef server(input, output, session):\n    # Create a dictionary to store tasks and descriptions for each list\n    lists_data = reactive.value({\n        list_id: {\"tasks\": [], \"descriptions\": []}\n        for list_id in LIST_NAMES.keys()\n    })\n    \n    changes_unsaved = reactive.value(False)\n    editing = reactive.value(False)\n        # Add these near the start of the server function with other reactive values\n    is_online = reactive.value(True)  # Track online status\n    pending_changes = reactive.value([])  # Queue of changes made while offline\n    loaded_file_timestamp = reactive.value(\"\")\n    showing_conflict_dialog = reactive.value(False)\n\n   \n    def format_metadata(timestamp):\n        return f\"--- METADATA ---\\nLast updated: {timestamp}\\n--- END METADATA ---\\n\\n\"\n    \n    def extract_metadata(content):\n        if \"--- METADATA ---\" not in content:\n            return \"\"  # Return empty string instead of None\n        try:\n            timestamp_line = content.split(\"--- METADATA ---\")[1].split(\"--- END METADATA ---\")[0]\n            timestamp = timestamp_line.split(\"Last updated: \")[1].strip()\n            return timestamp if timestamp else \"\"  # Return empty string if timestamp is empty\n        except:\n            return \"\"  # Return empty string on any error\n    \n    def check_for_conflicts():\n        if not input.github_token() or not input.github_repo():\n            return False\n        \n        try:\n            # GitHub API endpoint\n            repo = input.github_repo()\n            path = \"ToDoList.txt\"\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n    \n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n    \n            # Get the file content\n            response = requests.get(url, headers=headers)\n            \n            if response.status_code == 200:\n                # Decode content from base64\n                content = base64.b64decode(response.json()[\"content\"]).decode()\n                github_timestamp = extract_metadata(content)\n                stored_timestamp = loaded_file_timestamp.get()\n                \n                print(f\"Current GitHub timestamp: {github_timestamp}\")\n                print(f\"Stored local timestamp: {stored_timestamp}\")\n                \n                # Only detect conflict if both timestamps exist and are different\n                if github_timestamp and stored_timestamp and github_timestamp != stored_timestamp:\n                    print(\"Conflict detected!\")\n                    return True\n                print(\"No conflict detected\")\n            return False\n        except Exception as e:\n            print(f\"Error in check_for_conflicts: {str(e)}\")\n            return False\n    \n    @render.ui\n    def conflict_dialog():\n        if not showing_conflict_dialog.get():\n            return ui.div()\n        \n        return ui.card(\n            ui.h3(\"Conflict Detected!\", style=\"color: red;\"),\n            ui.p(\"The file on GitHub has been modified since you last loaded it.\"),\n            ui.p(\"What would you like to do?\"),\n            ui.div(\n                ui.input_action_button(\"resolve_conflict_overwrite\", \"Overwrite GitHub Version\", class_=\"btn-warning\"),\n                ui.input_action_button(\"resolve_conflict_reload\", \"Reload from GitHub\", class_=\"btn-info\"),\n                style=\"display: flex; gap: 10px;\"\n            )\n        )\n    \n    @reactive.effect\n    @reactive.event(input.resolve_conflict_overwrite)\n    def handle_conflict_overwrite():\n        showing_conflict_dialog.set(False)\n        # Force save without checking conflicts\n        save_to_github(force=True)\n    \n    \n    \n    \n    \n    def check_online_status():\n        try:\n            requests.get(\"https://api.github.com\", timeout=2)\n            return True\n        except (requests.ConnectionError, requests.Timeout):\n            return False       \n\n    def get_current_list():\n        return lists_data.get()[input.active_list()]\n\n    @reactive.effect\n    @reactive.event(input.add)\n    def add_task():\n        if input.task().strip():\n            current_data = lists_data.get().copy()\n            current_list = current_data[input.active_list()]\n            \n            # Changed from append() to insert(0, ...)\n            current_list[\"tasks\"].insert(0, input.task())\n            current_list[\"descriptions\"].insert(0, input.description())\n            \n            lists_data.set(current_data)\n            changes_unsaved.set(True)\n            ui.update_text(\"task\", value=\"\")\n        ui.update_text(\"description\", value=\"\")\n    \n    @render.ui\n    def task_selector():\n        current_list = get_current_list()\n        if not current_list[\"tasks\"]:\n            return ui.p(\"No tasks in this list\")\n        \n        options = {str(i): f\"{i}. {task}\" \n                  for i, task in enumerate(current_list[\"tasks\"], 1)}\n        \n        return ui.div(\n            ui.input_checkbox_group(\n                \"selected_tasks\",\n                \"Select Tasks to Move/Edit\",\n                options\n            )\n        )\n\n    @render.text\n    def online_status():\n        if not is_online.get():\n            return \"\ud83d\udcf4 Offline Mode - Changes will sync when online\"\n        return \"\ud83c\udf10 Online\"\n\n    \n    @render.ui\n    def task_lists_display():\n        selected_lists = input.display_lists()\n        if not selected_lists:\n            return ui.p(\"Please select lists to display\")\n        \n        col_width = 12 // len(selected_lists)\n        col_width = max(3, min(12, col_width))\n        \n        if not input.use_drag_drop():\n            # Original markdown view\n            columns = []\n            for list_id in selected_lists:\n                current_list = lists_data.get()[list_id]\n                current_tasks = current_list[\"tasks\"]\n                current_descriptions = current_list[\"descriptions\"]\n                \n                task_items = []\n                task_items.append(ui.h3(LIST_NAMES[list_id]))\n                \n                if not current_tasks:\n                    task_items.append(ui.p(\"No tasks in this list\"))\n                else:\n                    for i, (task, desc) in enumerate(zip(current_tasks, current_descriptions), 1):\n                        desc_paragraphs = [ui.p(p, style=\"text-indent:50px\") for p in desc.split('\\n')]\n                        task_html = ui.div(\n                            ui.h5(f\"\u2022 {task}\"),\n                            *desc_paragraphs,\n                            style=\"margin-bottom: 0;\"\n                        )\n                        task_items.append(task_html)\n                \n                column = ui.column(\n                    col_width,\n                    ui.card(\n                        *task_items,\n                        style=\"height: 100%;\"\n                    )\n                )\n                columns.append(column)\n            \n            return ui.row(*columns)\n        else:\n            # Drag and drop view\n            columns = []\n            for list_id in selected_lists:\n                current_list = lists_data.get()[list_id]\n                current_tasks = current_list[\"tasks\"]\n                current_descriptions = current_list[\"descriptions\"]\n                \n                task_items = []\n                \n                if not current_tasks:\n                    task_items.append(ui.p(\"No tasks in this list\"))\n                else:\n                    for i, (task, desc) in enumerate(zip(current_tasks, current_descriptions)):\n                        task_html = ui.div(\n                            {\"draggable\": \"true\",\n                             \"data-task-id\": f\"{list_id}-{i}\",\n                             \"data-list-id\": list_id,\n                             \"data-task-index\": str(i),\n                             \"ondragstart\": \"handleDragStart(event)\",\n                             \"ondragover\": \"handleDragOver(event)\",\n                             \"ondrop\": \"handleDrop(event)\",\n                             \"class\": \"draggable-task\"},\n                            ui.h5(task),\n                            ui.p(desc) if desc else \"\",\n                            style=\"cursor: move; padding: 10px; margin: 5px; border: 1px solid #ddd; border-radius: 4px;\"\n                        )\n                        task_items.append(task_html)\n                \n                column = ui.column(\n                    col_width,\n                    ui.div(\n                        {\"data-list-id\": list_id,\n                         \"class\": \"droppable-list\",\n                         \"ondragover\": \"handleDragOver(event)\",\n                         \"ondrop\": \"handleDrop(event)\"},\n                        ui.h3(LIST_NAMES[list_id]),\n                        *task_items,\n                        style=\"height: 100%; min-height: 100px; padding: 10px; border: 1px dashed #ccc; border-radius: 4px;\"\n                    )\n                )\n                columns.append(column)\n            \n            # Add required JavaScript\n            script = \"\"\"\n            function handleDragStart(event) {\n                event.dataTransfer.setData('text/plain', \n                    JSON.stringify({\n                        taskId: event.target.dataset.taskId,\n                        listId: event.target.dataset.listId,\n                        taskIndex: event.target.dataset.taskIndex\n                    })\n                );\n            }\n            \n            function handleDragOver(event) {\n                event.preventDefault();\n            }\n            \n            function handleDrop(event) {\n                event.preventDefault();\n                const data = JSON.parse(event.dataTransfer.getData('text/plain'));\n                \n                // Get target list and position\n                let targetElement = event.target;\n                while (targetElement && !targetElement.classList.contains('droppable-list') &&\n                       !targetElement.classList.contains('draggable-task')) {\n                    targetElement = targetElement.parentElement;\n                }\n                \n                if (!targetElement) return;\n                \n                const targetListId = targetElement.dataset.listId;\n                let targetIndex = -1;\n                \n                if (targetElement.classList.contains('draggable-task')) {\n                    targetIndex = parseInt(targetElement.dataset.taskIndex);\n                }\n                \n                // Send move information to Shiny\n                const moveInfo = {\n                    sourceListId: data.listId,\n                    sourceIndex: parseInt(data.taskIndex),\n                    targetListId: targetListId,\n                    targetIndex: targetIndex\n                };\n                \n                Shiny.setInputValue('drag_drop_move', moveInfo);\n            }\n            \"\"\"\n            \n            return ui.tags.div(\n                ui.tags.script(script),\n                ui.row(*columns)\n            )\n\n    @render.ui\n    def move_controls():\n        if not input.selected_tasks():\n            return ui.div()\n            \n        current_list_id = input.active_list()\n        move_options = {k: v for k, v in LIST_NAMES.items() if k != current_list_id}\n        \n        return ui.card(\n            {\"class\": \"control-panel\"},\n            ui.div(\n                {\"class\": \"move-controls\"},\n                ui.input_radio_buttons(\n                    \"move_to_list\",\n                    \"Move selected tasks to:\",\n                    move_options,\n                    inline=True\n                ),\n                ui.input_action_button(\n                    \"move_tasks\", \n                    \"Move Tasks\", \n                    class_=\"btn-info\"\n                )\n            )\n        )\n    \n    \n    @reactive.effect\n    @reactive.event(input.drag_drop_move)\n    def handle_drag_drop_move():\n        move_info = input.drag_drop_move()\n        current_data = lists_data.get().copy()\n        \n        source_list = current_data[move_info[\"sourceListId\"]]\n        source_index = move_info[\"sourceIndex\"]\n        target_list_id = move_info[\"targetListId\"]\n        target_index = move_info[\"targetIndex\"]\n        \n        # Get the task and description to move\n        task = source_list[\"tasks\"][source_index]\n        desc = source_list[\"descriptions\"][source_index]\n        \n        # Remove from source\n        source_list[\"tasks\"].pop(source_index)\n        source_list[\"descriptions\"].pop(source_index)\n        \n        # Add to target\n        if target_list_id == move_info[\"sourceListId\"]:\n            # Moving within the same list\n            if target_index >= 0:\n                # Insert at specific position\n                target_index = min(target_index, len(source_list[\"tasks\"]))\n                source_list[\"tasks\"].insert(target_index, task)\n                source_list[\"descriptions\"].insert(target_index, desc)\n            else:\n                # Append to end\n                source_list[\"tasks\"].append(task)\n                source_list[\"descriptions\"].append(desc)\n        else:\n            # Moving to different list\n            target_list = current_data[target_list_id]\n            if target_index >= 0:\n                # Insert at specific position\n                target_index = min(target_index, len(target_list[\"tasks\"]))\n                target_list[\"tasks\"].insert(target_index, task)\n                target_list[\"descriptions\"].insert(target_index, desc)\n            else:\n                # Append to end\n                target_list[\"tasks\"].append(task)\n                target_list[\"descriptions\"].append(desc)\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)\n\n\n    @render.ui\n    def edit_controls():\n        if not input.selected_tasks():\n            return ui.div()\n        \n        if len(input.selected_tasks()) == 1:\n            if editing.get():\n                task_idx = int(input.selected_tasks()[0]) - 1\n                current_list = get_current_list()\n                \n                return ui.card(\n                    {\"class\": \"control-panel\"},\n                    ui.h4(\"Edit Task\"),\n                    ui.input_text(\n                        \"edit_task\",\n                        \"Task\",\n                        value=current_list[\"tasks\"][task_idx]\n                    ),\n                    ui.input_text_area(\n                        \"edit_description\",\n                        \"Description\",\n                        value=current_list[\"descriptions\"][task_idx],\n                        height=\"100px\"\n                    ),\n                    ui.div(\n                        {\"class\": \"button-container\"},\n                        ui.input_action_button(\"save_edit\", \"Save\", class_=\"btn-success\"),\n                        ui.input_action_button(\"cancel_edit\", \"Cancel\", class_=\"btn-secondary\")\n                    )\n                )\n            else:\n                return ui.card(\n                    {\"class\": \"control-panel\"},\n                    ui.div(\n                        {\"class\": \"button-container\"},\n                        ui.input_action_button(\"delete_task\", \"Delete Task\", class_=\"btn-danger\"),\n                        ui.input_action_button(\"start_edit\", \"Edit Task\", class_=\"btn-warning\"),\n                        ui.input_action_button(\"move_up\", \"\u2191 Move Up\", class_=\"btn-primary\"),\n                        ui.input_action_button(\"move_down\", \"\u2193 Move Down\", class_=\"btn-primary\")\n                    )\n                )\n        else:\n            return ui.card(\n                {\"class\": \"control-panel\"},\n                ui.div(\n                    {\"class\": \"button-container\"},\n                    ui.input_action_button(\"delete_task\", \"Delete Selected Tasks\", class_=\"btn-danger\")\n                )\n            )\n        \n\n\n\n    \n\n    @reactive.effect\n    @reactive.event(input.move_tasks)\n    def move_selected_tasks():\n        if not input.selected_tasks():\n            return\n            \n        selected_indices = [int(idx) - 1 for idx in input.selected_tasks()]\n        source_list_id = input.active_list()\n        target_list_id = input.move_to_list()\n        \n        current_data = lists_data.get().copy()\n        source_list = current_data[source_list_id]\n        target_list = current_data[target_list_id]\n        \n        # Get tasks and descriptions to move\n        tasks_to_move = [source_list[\"tasks\"][i] for i in selected_indices]\n        descriptions_to_move = [source_list[\"descriptions\"][i] for i in selected_indices]\n        \n        # Add to target list\n        target_list[\"tasks\"].extend(tasks_to_move)\n        target_list[\"descriptions\"].extend(descriptions_to_move)\n        \n        # Remove from source list (in reverse order to maintain indices)\n        for i in sorted(selected_indices, reverse=True):\n            source_list[\"tasks\"].pop(i)\n            source_list[\"descriptions\"].pop(i)\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)  # Add this line\n\n    @reactive.effect\n    @reactive.event(input.start_edit)\n    def start_editing():\n        editing.set(True)\n\n    @reactive.effect\n    @reactive.event(input.cancel_edit)\n    def cancel_editing():\n        editing.set(False)\n\n    @reactive.effect\n    @reactive.event(input.save_edit)\n    def save_edit():\n        if not input.selected_tasks():\n            return\n            \n        task_idx = int(input.selected_tasks()[0]) - 1\n        current_data = lists_data.get().copy()\n        current_list = current_data[input.active_list()]\n        \n        current_list[\"tasks\"][task_idx] = input.edit_task()\n        current_list[\"descriptions\"][task_idx] = input.edit_description()\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)  # Add this line\n        editing.set(False)\n\n    # Add a reactive value for GitHub save status\n    github_status = reactive.value(\"\")\n\n  \n    @render.text\n    def github_status_output():\n        return github_status.get()\n\n    @reactive.effect\n    @reactive.event(input.move_up)\n    def move_task_up():\n        if not input.selected_tasks() or len(input.selected_tasks()) != 1:\n            return\n            \n        task_idx = int(input.selected_tasks()[0]) - 1\n        if task_idx <= 0:  # Can't move up if already at top\n            return\n            \n        current_data = lists_data.get().copy()\n        current_list = current_data[input.active_list()]\n        \n        # Swap tasks\n        current_list[\"tasks\"][task_idx], current_list[\"tasks\"][task_idx-1] = \\\n            current_list[\"tasks\"][task_idx-1], current_list[\"tasks\"][task_idx]\n        \n        # Swap descriptions\n        current_list[\"descriptions\"][task_idx], current_list[\"descriptions\"][task_idx-1] = \\\n            current_list[\"descriptions\"][task_idx-1], current_list[\"descriptions\"][task_idx]\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)  # Add this line\n        \n        # Update the selection to follow the moved task\n        ui.update_checkbox_group(\n            \"selected_tasks\",\n            selected=[str(task_idx)]  # Index is 0-based, but UI is 1-based\n        )\n\n    @reactive.effect\n    @reactive.event(input.move_down)\n    def move_task_down():\n        if not input.selected_tasks() or len(input.selected_tasks()) != 1:\n            return\n            \n        task_idx = int(input.selected_tasks()[0]) - 1\n        current_data = lists_data.get().copy()\n        current_list = current_data[input.active_list()]\n        \n        if task_idx >= len(current_list[\"tasks\"]) - 1:  # Can't move down if already at bottom\n            return\n            \n        # Swap tasks\n        current_list[\"tasks\"][task_idx], current_list[\"tasks\"][task_idx+1] = \\\n            current_list[\"tasks\"][task_idx+1], current_list[\"tasks\"][task_idx]\n        \n        # Swap descriptions\n        current_list[\"descriptions\"][task_idx], current_list[\"descriptions\"][task_idx+1] = \\\n            current_list[\"descriptions\"][task_idx+1], current_list[\"descriptions\"][task_idx]\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)  # Add this line\n        \n        # Update the selection to follow the moved task\n        ui.update_checkbox_group(\n            \"selected_tasks\",\n            selected=[str(task_idx + 2)]  # Index is 0-based, but UI is 1-based\n        )    \n    \n    @reactive.effect\n    @reactive.event(input.delete_task)\n    def delete_task():\n        if not input.selected_tasks():\n            return\n            \n        selected_indices = [int(idx) - 1 for idx in input.selected_tasks()]\n        current_data = lists_data.get().copy()\n        current_list = current_data[input.active_list()]\n        \n        # Remove tasks and descriptions in reverse order to maintain correct indices\n        for idx in sorted(selected_indices, reverse=True):\n            current_list[\"tasks\"].pop(idx)\n            current_list[\"descriptions\"].pop(idx)\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)    \n   \n    @reactive.effect\n    @reactive.event(lists_data, input.autosave_enabled)\n    def auto_save():\n        # Check online status first\n        is_online.set(check_online_status())\n        \n        # If autosave was just disabled but there are no actual changes,\n        # make sure changes_unsaved is False\n        if not input.autosave_enabled() and not changes_unsaved.get():\n            return\n    \n        # If there are no changes, nothing to do\n        if not changes_unsaved.get():\n            return\n    \n        # If autosave is disabled, keep existing unsaved state\n        if not input.autosave_enabled():\n            return\n    \n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in GitHub credentials to enable auto-save\")\n            return\n    \n        # If we're offline, queue the changes\n        if not is_online.get():\n            if changes_unsaved.get():\n                github_status.set(\"\u26a0\ufe0f Changes pending - Currently offline\")\n                # Store the current state\n                pending_changes.set(pending_changes.get() + [lists_data.get()])\n            return\n    \n        # Check for conflicts first, before creating new timestamp\n        path = \"ToDoList.txt\"\n        try:\n            # GitHub API endpoint\n            repo = input.github_repo()\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n            \n            # Get current GitHub content\n            response = requests.get(url, headers=headers)\n            if response.status_code == 200:\n                content = base64.b64decode(response.json()[\"content\"]).decode()\n                github_timestamp = extract_metadata(content)\n                stored_timestamp = loaded_file_timestamp.get()\n                \n                print(f\"Auto-save - GitHub timestamp: {github_timestamp}\")\n                print(f\"Auto-save - Local timestamp: {stored_timestamp}\")\n                \n                if github_timestamp != stored_timestamp:\n                    print(\"Auto-save - Conflict detected!\")\n                    showing_conflict_dialog.set(True)\n                    return\n        except Exception as e:\n            print(f\"Auto-save - Error checking conflicts: {str(e)}\")\n            return\n    \n        try:\n            # Now proceed with save\n            data = lists_data.get()\n            current_timestamp = datetime.now(timezone.utc).isoformat()\n            formatted_data = format_metadata(current_timestamp)\n            \n            for list_id, list_name in LIST_NAMES.items():\n                formatted_data += f\"=== {list_name} ===\\n\"\n                list_content = data[list_id]\n                for task, desc in zip(list_content[\"tasks\"], list_content[\"descriptions\"]):\n                    formatted_data += f\"- {task}\\n\"\n                    if desc.strip():\n                        formatted_data += f\"  |{desc}\\n\"\n                formatted_data += \"\\n\"\n    \n            # Check if file exists and get its SHA\n            try:\n                response = requests.get(url, headers=headers)\n                sha = response.json()[\"sha\"] if response.status_code == 200 else None\n            except:\n                sha = None\n    \n            # Prepare the content\n            content = base64.b64encode(formatted_data.encode()).decode()\n    \n            # Prepare the data for the API request\n            data = {\n                \"message\": \"Auto-update task lists\",\n                \"content\": content,\n            }\n            if sha:\n                data[\"sha\"] = sha\n    \n            # Make the API request\n            response = requests.put(url, headers=headers, json=data)\n    \n            if response.status_code in [200, 201]:\n                github_status.set(\"\u2713 Changes saved automatically\")\n                changes_unsaved.set(False)\n                loaded_file_timestamp.set(str(current_timestamp))\n            else:\n                github_status.set(f\"\u274c Error auto-saving: {response.status_code}\")\n    \n        except requests.RequestException as e:\n            github_status.set(\"\u26a0\ufe0f Changes pending - Network error\")\n        except Exception as e:\n            github_status.set(f\"\u274c Error auto-saving: {str(e)}\")\n\n\n    @reactive.effect\n    def handle_online_status():\n        # Periodically check online status\n        current_online_status = check_online_status()\n        is_online.set(current_online_status)\n        \n        # If we just came back online and have pending changes\n        if current_online_status and pending_changes.get():\n            try:\n                # Process pending changes\n                if input.autosave_enabled():\n                    # Trigger a save with the latest state\n                    lists_data.set(pending_changes.get()[-1])  # Use most recent change\n                    pending_changes.set([])  # Clear the queue\n                    github_status.set(\"\u2713 Syncing changes after coming back online...\")\n            except Exception as e:\n                github_status.set(f\"\u274c Error syncing changes: {str(e)}\")\n    \n    @reactive.effect\n    @reactive.event(input.quick_save)\n    def handle_quick_save():\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in GitHub credentials in the sidebar first\")\n            return\n    \n        # Check for conflicts first, before creating new timestamp\n        path = \"ToDoList.txt\"\n        try:\n            # GitHub API endpoint\n            repo = input.github_repo()\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n            \n            # Get current GitHub content\n            response = requests.get(url, headers=headers)\n            if response.status_code == 200:\n                content = base64.b64decode(response.json()[\"content\"]).decode()\n                github_timestamp = extract_metadata(content)\n                stored_timestamp = loaded_file_timestamp.get()\n                \n                print(f\"Quick save - GitHub timestamp: {github_timestamp}\")\n                print(f\"Quick save - Local timestamp: {stored_timestamp}\")\n                \n                if github_timestamp != stored_timestamp:\n                    print(\"Quick save - Conflict detected!\")\n                    showing_conflict_dialog.set(True)\n                    return\n        except Exception as e:\n            print(f\"Quick save - Error checking conflicts: {str(e)}\")\n            return\n    \n        try:\n            # Now proceed with save\n            data = lists_data.get()\n            current_timestamp = datetime.now(timezone.utc).isoformat()\n            formatted_data = format_metadata(current_timestamp)\n            \n            for list_id, list_name in LIST_NAMES.items():\n                formatted_data += f\"=== {list_name} ===\\n\"\n                list_content = data[list_id]\n                for task, desc in zip(list_content[\"tasks\"], list_content[\"descriptions\"]):\n                    formatted_data += f\"- {task}\\n\"\n                    if desc.strip():\n                        formatted_data += f\"  |{desc}\\n\"\n                formatted_data += \"\\n\"\n    \n            # Check if file exists and get its SHA\n            try:\n                response = requests.get(url, headers=headers)\n                sha = response.json()[\"sha\"] if response.status_code == 200 else None\n            except:\n                sha = None\n    \n            # Prepare the content\n            content = base64.b64encode(formatted_data.encode()).decode()\n    \n            # Prepare the data for the API request\n            data = {\n                \"message\": \"Quick update task lists\",\n                \"content\": content,\n            }\n            if sha:\n                data[\"sha\"] = sha\n    \n            # Make the API request\n            response = requests.put(url, headers=headers, json=data)\n    \n            if response.status_code in [200, 201]:\n                github_status.set(\"Successfully saved to GitHub!\")\n                changes_unsaved.set(False)\n                loaded_file_timestamp.set(str(current_timestamp))\n            else:\n                github_status.set(f\"Error saving to GitHub: {response.status_code}\")\n    \n        except Exception as e:\n            github_status.set(f\"Error: {str(e)}\")\n\n    \n    def save_to_github(force=False):\n        path = \"ToDoList.txt\"\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in all GitHub fields\")\n            return\n    \n        # Check for conflicts first, before creating new timestamp\n        if not force:\n            try:\n                # GitHub API endpoint\n                repo = input.github_repo()\n                url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n                headers = {\n                    \"Authorization\": f\"token {input.github_token()}\",\n                    \"Accept\": \"application/vnd.github.v3+json\"\n                }\n                \n                # Get current GitHub content\n                response = requests.get(url, headers=headers)\n                if response.status_code == 200:\n                    content = base64.b64decode(response.json()[\"content\"]).decode()\n                    github_timestamp = extract_metadata(content)\n                    stored_timestamp = loaded_file_timestamp.get()\n                    \n                    print(f\"GitHub timestamp: {github_timestamp}\")\n                    print(f\"Local timestamp: {stored_timestamp}\")\n                    \n                    if github_timestamp != stored_timestamp:\n                        print(\"Conflict detected!\")\n                        showing_conflict_dialog.set(True)\n                        return\n            except Exception as e:\n                print(f\"Error checking conflicts: {str(e)}\")\n                return\n    \n        try:\n            # Now proceed with save\n            data = lists_data.get()\n            current_timestamp = datetime.now(timezone.utc).isoformat()\n            formatted_data = format_metadata(current_timestamp)\n            \n            for list_id, list_name in LIST_NAMES.items():\n                formatted_data += f\"=== {list_name} ===\\n\"\n                list_content = data[list_id]\n                for task, desc in zip(list_content[\"tasks\"], list_content[\"descriptions\"]):\n                    formatted_data += f\"- {task}\\n\"\n                    if desc.strip():\n                        formatted_data += f\"  |{desc}\\n\"\n                formatted_data += \"\\n\"\n    \n            # GitHub API endpoint\n            repo = input.github_repo()\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n    \n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n    \n            # Check if file exists and get its SHA\n            try:\n                response = requests.get(url, headers=headers)\n                sha = response.json()[\"sha\"] if response.status_code == 200 else None\n            except:\n                sha = None\n    \n            # Prepare the content\n            content = base64.b64encode(formatted_data.encode()).decode()\n    \n            # Prepare the data for the API request\n            data = {\n                \"message\": \"Update task lists\",\n                \"content\": content,\n            }\n            if sha:\n                data[\"sha\"] = sha\n    \n            # Make the API request\n            response = requests.put(url, headers=headers, json=data)\n    \n            if response.status_code in [200, 201]:\n                github_status.set(\"Successfully saved to GitHub!\")\n                changes_unsaved.set(False)\n                # Store the timestamp as string\n                loaded_file_timestamp.set(str(current_timestamp))\n            else:\n                github_status.set(f\"Error saving to GitHub: {response.status_code}\")\n    \n        except Exception as e:\n            github_status.set(f\"Error: {str(e)}\")\n    \n    \n    \n    \n    \n\n\n\n\n    \n    def load_list_names_from_github():\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in GitHub credentials to load list names\")\n            return False\n    \n        try:\n            # GitHub API endpoint\n            repo = input.github_repo()\n            path = \"ToDoListNames.txt\"\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n    \n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n    \n            # Get the file content\n            response = requests.get(url, headers=headers)\n            \n            if response.status_code == 404:\n                # File doesn't exist yet, this is okay\n                github_status.set(\"No saved list names found, using defaults\")\n                return True\n            elif response.status_code == 200:\n                # Decode content from base64\n                content = base64.b64decode(response.json()[\"content\"]).decode()\n                \n                # Parse the content and update LIST_NAMES\n                for line in content.strip().split('\\n'):\n                    if ':' in line:\n                        list_id, name = line.split(':', 1)\n                        if list_id in LIST_NAMES:\n                            LIST_NAMES[list_id] = name\n    \n                # Update UI elements\n                ui.update_radio_buttons(\n                    \"active_list\",\n                    choices=LIST_NAMES\n                )\n                ui.update_checkbox_group(\n                    \"display_lists\",\n                    choices=LIST_NAMES,\n                    selected=input.display_lists()\n                )\n                \n                github_status.set(\"Successfully loaded list names from GitHub!\")\n                return True\n            else:\n                github_status.set(f\"Error loading list names from GitHub: {response.status_code}\")\n                return False\n    \n        except Exception as e:\n            github_status.set(f\"Error loading list names: {str(e)}\")\n            return False    \n\n    def perform_load_from_github():        \n        # First load the list names\n        if not load_list_names_from_github():\n            return\n                \n        path = \"ToDoList.txt\"\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in all GitHub fields\")\n            return\n    \n        try:\n            # GitHub API endpoint\n            repo = input.github_repo()\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n    \n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n    \n            # Get the file content\n            response = requests.get(url, headers=headers)\n            \n            if response.status_code == 200:\n                # Decode content from base64\n                content = base64.b64decode(response.json()[\"content\"]).decode()\n                \n                # Extract and store timestamp\n                timestamp = extract_metadata(content)\n                print(f\"Loading file with timestamp: {timestamp}\")\n                loaded_file_timestamp.set(str(timestamp))  # Ensure it's stored as string\n                \n                # Remove metadata section before parsing\n                if \"--- END METADATA ---\" in content:\n                    content = content.split(\"--- END METADATA ---\")[1].strip()\n                \n                # Parse the content\n                current_list_id = None\n                new_data = {list_id: {\"tasks\": [], \"descriptions\": []} \n                        for list_id in LIST_NAMES.keys()}\n                \n                lines = [line.rstrip() for line in content.split('\\n')]\n                i = 0\n                while i < len(lines):\n                    line = lines[i]\n                    if not line:\n                        i += 1\n                        continue\n                        \n                    # Check if this is a list header\n                    if line.startswith('===') and line.endswith('==='):\n                        list_name = line.strip('= ')\n                        # Find the list_id for this list_name\n                        current_list_id = next(\n                            (k for k, v in LIST_NAMES.items() if v == list_name),\n                            None\n                        )\n                    # Check if this is a task\n                    elif line.startswith('- ') and current_list_id:\n                        task = line[2:]  # Remove the '- ' prefix\n                        new_data[current_list_id][\"tasks\"].append(task)\n                        \n                        # Look ahead for description\n                        desc = \"\"\n                        if i + 1 < len(lines):\n                            next_line = lines[i + 1]\n                            if next_line.startswith('  |'):\n                                desc = next_line[3:].strip()  # Remove '  |' prefix\n                                i += 1  # Skip the description line\n                        new_data[current_list_id][\"descriptions\"].append(desc)\n                    \n                    i += 1\n    \n                # Update the lists_data\n                lists_data.set(new_data)\n                changes_unsaved.set(False)  # Reset unsaved changes flag\n                showing_conflict_dialog.set(False)  # Hide conflict dialog if it was showing\n                github_status.set(\"Successfully loaded from GitHub!\")\n            else:\n                github_status.set(f\"Error loading from GitHub: {response.status_code}\")\n    \n        except Exception as e:\n            github_status.set(f\"Error loading: {str(e)}\")\n    \n    @reactive.effect\n    @reactive.event(input.load_github)      \n    def load_from_github():\n        perform_load_from_github()\n    \n    @reactive.effect\n    @reactive.event(input.resolve_conflict_reload)\n    def handle_conflict_reload():\n        showing_conflict_dialog.set(False)\n        perform_load_from_github()\n\n    \n \n    editing_names = reactive.value(False)\n    \n    \n    @render.ui\n    def list_name_controls():\n        if not editing_names.get():\n            return ui.div()\n            \n        inputs = []\n        for list_id, current_name in LIST_NAMES.items():\n            inputs.extend([\n                ui.input_text(\n                    f\"name_{list_id}\",\n                    f\"Name for {list_id}:\",\n                    value=current_name\n                ),\n                ui.br()\n            ])\n        \n        return ui.div(\n            ui.card(\n                *inputs,\n                ui.div(\n                    ui.input_action_button(\n                        \"save_list_names\", \n                        \"Save Names\", \n                        class_=\"btn-success\"\n                    ),\n                    ui.input_action_button(\n                        \"cancel_list_names\", \n                        \"Cancel\", \n                        class_=\"btn-secondary\"\n                    ),\n                    style=\"display: flex; gap: 10px;\"\n                )\n            )\n        )\n\n    @reactive.effect\n    @reactive.event(input.edit_list_names)\n    def start_editing_names():\n        editing_names.set(True)\n\n    @reactive.effect\n    @reactive.event(input.cancel_list_names)\n    def cancel_editing_names():\n        editing_names.set(False)\n\n    @reactive.effect\n    @reactive.event(input.save_list_names)\n    def save_list_names():\n        # Update the LIST_NAMES dictionary with new values\n        for list_id in LIST_NAMES.keys():\n            LIST_NAMES[list_id] = getattr(input, f\"name_{list_id}\")()\n        \n        # Update any UI elements that depend on list names\n        ui.update_radio_buttons(\n            \"active_list\",\n            choices=LIST_NAMES\n        )\n        ui.update_checkbox_group(\n            \"display_lists\",\n            choices=LIST_NAMES,\n            selected=input.display_lists()\n        )\n        \n        # Save to GitHub if credentials are available\n        save_list_names_to_github()\n        \n        editing_names.set(False)\n        changes_unsaved.set(True)\n\n    def save_list_names_to_github():\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in GitHub credentials to save list names\")\n            return False\n\n        try:\n            # GitHub API endpoint\n            repo = input.github_repo()\n            path = \"ToDoListNames.txt\"\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n\n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n\n            # Format the list names data\n            formatted_data = \"\\n\".join([f\"{list_id}:{name}\" for list_id, name in LIST_NAMES.items()])\n            content = base64.b64encode(formatted_data.encode()).decode()\n\n            # Check if file exists\n            try:\n                response = requests.get(url, headers=headers)\n                sha = response.json()[\"sha\"] if response.status_code == 200 else None\n            except:\n                sha = None\n\n            # Prepare the data for the API request\n            data = {\n                \"message\": \"Update list names\",\n                \"content\": content,\n            }\n            if sha:\n                data[\"sha\"] = sha\n\n            # Make the API request\n            response = requests.put(url, headers=headers, json=data)\n\n            if response.status_code in [200, 201]:\n                github_status.set(\"Successfully saved list names to GitHub!\")\n                return True\n            else:\n                github_status.set(f\"Error saving list names to GitHub: {response.status_code}\")\n                return False\n\n        except Exception as e:\n            github_status.set(f\"Error saving list names: {str(e)}\")\n            return False\n\n   \n    @render.ui\n    def manual_save_button():\n        if not input.autosave_enabled() and changes_unsaved.get():\n            return ui.input_action_button(\n                \"save_github\",  # Changed from manual_save to save_github\n                \"Save Changes to GitHub\",\n                class_=\"btn-success\"\n            )\n        return ui.div()\n    \n   \n    @render.text\n    def unsaved_changes_alert():\n        if not input.autosave_enabled() and changes_unsaved.get():\n            return \"\u26a0\ufe0f You have unsaved changes\"\n        return \"\"\n    \n    \napp = App(app_ui, server)", "type": "text"}, {"name": "README.md", "content": "# ToDo\n\n# shiny4Python\nCreate a shiny for Python app.  You can create both a `site` or full app based on `FastAPI`.\n\nIn these lines we:\n- Install `shiny` & `shinylive`\n- Create a Hello world app\n- Run the [app](https://shiny.rstudio.com/py/docs/deploy.html) based on the `FastAPI`\n- Create as a [static website](https://shiny.rstudio.com/py/docs/shinylive.html) with `WebAssembly`\n\n```\npip install shiny\npip install shinylive\nshiny create .\nshiny run \nshinylive export . docs\n```\n\n..........rollback to put on top.  conflict simplify to just alert and give option to reload or save local\n\n\n\n`Note:` We output the website to `docs` to host on a Github Page\n\n\n![image](https://user-images.githubusercontent.com/33904170/215349262-68b36efa-ceff-40ea-ae80-052303a7258b.png)\n", "type": "text"}]