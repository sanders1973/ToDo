[{"name": "app.py", "content": "from shiny import App, reactive, render, ui\nimport json\nimport base64\nimport requests\nimport os\n\n# Define the list names\nLIST_NAMES = {\n    \"list1\": \"List 1\",\n    \"list2\": \"List 2\",\n    \"list3\": \"List 3\",\n    \"list4\": \"List 4\",\n    \"list5\": \"List 5\",\n    \"list6\": \"List 6\",\n    \"list7\": \"List 7\",\n    \"list8\": \"List 8\",\n    \"list9\": \"List 9\",\n    \"list10\": \"List 10\"\n}\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.accordion(\n            ui.accordion_panel(\n                \"Settings\",\n                ui.output_text(\"online_status\"),\n                ui.input_dark_mode(id=None, mode=\"dark\"),\n                ui.input_switch(\"autosave_enabled\", \"Enable GitHub Auto-save\", value=True),\n                open=False  # This makes it start collapsed\n            ),\n            id=\"settings_accordion\"\n        ),\n        \n        ui.input_text(\"task\", \"Enter Task\"),\n        ui.input_text_area(\"description\", \"Enter Description\", height=\"100px\"),  # Changed this line\n        ui.input_action_button(\"add\", \"Add Task\", class_=\"btn-primary\"),\n        ui.output_text(\"unsaved_changes_alert\"),\n        ui.output_ui(\"manual_save_button\"),\n        # ui.hr(),\n      #  ui.h4(\"Manage Tasks\"),\n        ui.output_ui(\"task_selector\"),\n      \n       # ui.hr(),\n      #  ui.h4(\"Save to GitHub\"),\n        ui.input_text(\n            \"github_repo\",\n            \"Repository (user/repo)\",\n            value=\"\",\n            autocomplete=\"username/rep\"\n        ),\n        ui.input_password(\n            \"github_token\",\n            \"Github Token\",\n            value=\"\"\n        ),\n        ui.output_text(\"github_status_output\"),\n        ui.input_action_button(\"load_github\", \"Load from GitHub\", class_=\"btn-info\"),\n      #  ui.hr(),\n      #  ui.h4(\"List Settings\"),\n        ui.input_action_button(\"edit_list_names\", \"Edit List Names\", class_=\"btn-secondary\"),\n        ui.output_ui(\"list_name_controls\"),\n        width=350\n    ),\n\n    ui.card(\n        ui.input_radio_buttons(\n            \"active_list\",\n            \"Working List (for adding/editing)\",\n            LIST_NAMES,\n            inline=True\n        ),\n        style=\"margin-bottom: 0;\"\n    ),\n    ui.output_ui(\"edit_controls\"),\n    ui.output_ui(\"move_controls\"),\n  \n    ui.card(\n        ui.row(\n            ui.column(12,\n                ui.input_checkbox_group(\n                    \"display_lists\",\n                    \"Select Lists to Display\",\n                    LIST_NAMES,\n                    selected=[\"list1\"],\n                    inline=True\n                )\n            )\n        ),\n       \n        ui.output_ui(\"task_lists_display\")\n    )\n)\n\n\ndef server(input, output, session):\n    # Create a dictionary to store tasks and descriptions for each list\n    lists_data = reactive.value({\n        list_id: {\"tasks\": [], \"descriptions\": []}\n        for list_id in LIST_NAMES.keys()\n    })\n    \n    changes_unsaved = reactive.value(False)\n    editing = reactive.value(False)\n        # Add these near the start of the server function with other reactive values\n    is_online = reactive.value(True)  # Track online status\n    pending_changes = reactive.value([])  # Queue of changes made while offline\n    \n\n    def check_online_status():\n        try:\n            requests.get(\"https://api.github.com\", timeout=2)\n            return True\n        except (requests.ConnectionError, requests.Timeout):\n            return False       \n\n    def get_current_list():\n        return lists_data.get()[input.active_list()]\n\n    @reactive.effect\n    @reactive.event(input.add)\n    def add_task():\n        if input.task().strip():\n            current_data = lists_data.get().copy()\n            current_list = current_data[input.active_list()]\n            \n            current_list[\"tasks\"].append(input.task())\n            current_list[\"descriptions\"].append(input.description())\n            \n            lists_data.set(current_data)\n            changes_unsaved.set(True)  # Add this line\n            ui.update_text(\"task\", value=\"\")\n            ui.update_text(\"description\", value=\"\")\n\n    \n    @render.ui\n    def task_selector():\n        current_list = get_current_list()\n        if not current_list[\"tasks\"]:\n            return ui.p(\"No tasks in this list\")\n        \n        options = {str(i): f\"{i}. {task}\" \n                  for i, task in enumerate(current_list[\"tasks\"], 1)}\n        \n        return ui.div(\n            ui.input_checkbox_group(\n                \"selected_tasks\",\n                \"Select Tasks to Move/Edit\",\n                options\n            )\n        )\n\n    @render.text\n    def online_status():\n        if not is_online.get():\n            return \"\ud83d\udcf4 Offline Mode - Changes will sync when online\"\n        return \"\ud83c\udf10 Online\"\n\n    \n    @render.ui\n    def task_lists_display():\n        selected_lists = input.display_lists()\n        if not selected_lists:\n            return ui.p(\"Please select lists to display\")\n        \n        col_width = 12 // len(selected_lists)\n        col_width = max(3, min(12, col_width))\n        \n        columns = []\n        for list_id in selected_lists:\n            current_list = lists_data.get()[list_id]\n            current_tasks = current_list[\"tasks\"]\n            current_descriptions = current_list[\"descriptions\"]\n            \n            task_items = []\n            task_items.append(ui.h3(LIST_NAMES[list_id]))\n            \n            if not current_tasks:\n                task_items.append(ui.p(\"No tasks in this list\"))\n            else:\n                for i, (task, desc) in enumerate(zip(current_tasks, current_descriptions), 1):\n                    desc_paragraphs = [ui.p(p, style=\"text-indent:50px\") for p in desc.split('\\n')]\n                    task_html = ui.div(\n                        ui.h5(f\"\u2022 {task}\"),\n                        *desc_paragraphs,\n                        style=\"margin-bottom: 0;\"\n                    )\n                    task_items.append(task_html)\n                \n            column = ui.column(\n                col_width,\n                ui.card(\n                    *task_items,\n                    style=\"height: 100%;\"\n                )\n            )\n            columns.append(column)\n        \n        return ui.row(*columns)\n\n    \n    @render.ui\n    def move_controls():\n        if not input.selected_tasks():\n            return ui.div()  # Return empty div without a card when no tasks selected\n            \n        current_list_id = input.active_list()\n        move_options = {k: v for k, v in LIST_NAMES.items() if k != current_list_id}\n        \n        return ui.card(\n            ui.div(\n                ui.div(\n                    ui.input_radio_buttons(\n                        \"move_to_list\",\n                        \"Move selected tasks to:\",\n                        move_options,\n                        inline=True\n                    ),\n                    ui.input_action_button(\n                        \"move_tasks\", \n                        \"Move Tasks\", \n                        class_=\"btn-info\"\n                    ),\n                    style=\"display: flex; align-items: center; gap: 0;\"\n                )\n            ),\n            style=\"margin-bottom: 0;\"\n        )\n\n    @render.ui\n    def edit_controls():\n        if not input.selected_tasks():\n            return ui.div()  # Return empty div without a card when no tasks selected\n        \n        # Show controls based on selection\n        if len(input.selected_tasks()) == 1:\n            # Single item selected - show all controls\n            if editing.get():\n                # Show edit form\n                task_idx = int(input.selected_tasks()[0]) - 1\n                current_list = get_current_list()\n                \n                return ui.card(  # Now wrap in card only when there's content\n                    ui.h4(\"Edit Task\"),\n                    ui.input_text(\n                        \"edit_task\",\n                        \"Task\",\n                        value=current_list[\"tasks\"][task_idx]\n                    ),\n                    ui.input_text_area(\n                        \"edit_description\",\n                        \"Description\",\n                        value=current_list[\"descriptions\"][task_idx],\n                        height=\"100px\"\n                    ),\n                    ui.div(\n                        ui.input_action_button(\"save_edit\", \"Save\", class_=\"btn-success\"),\n                        ui.input_action_button(\"cancel_edit\", \"Cancel\", class_=\"btn-secondary\"),\n                        style=\"display: flex; gap: 10px;\"\n                    )\n                )\n            else:\n                # Show action buttons for single selection\n                return ui.card(  # Now wrap in card only when there's content\n                    ui.div(\n                        ui.input_action_button(\"delete_task\", \"Delete Task\", class_=\"btn-danger\"),\n                        ui.input_action_button(\"start_edit\", \"Edit Task\", class_=\"btn-warning\"),\n                        ui.input_action_button(\"move_up\", \"\u2191 Move Up\", class_=\"btn-primary\"),\n                        ui.input_action_button(\"move_down\", \"\u2193 Move Down\", class_=\"btn-primary\"),\n                        style=\"display: flex; gap: 10px; flex-wrap: wrap;\"\n                    )\n                )\n        else:\n            # Multiple items selected - only show delete button\n            return ui.card(  # Now wrap in card only when there's content\n                ui.div(\n                    ui.input_action_button(\"delete_task\", \"Delete Selected Tasks\", class_=\"btn-danger\"),\n                    style=\"display: flex; gap: 10px;\"\n                )\n            )\n\n\n\n\n    \n\n    @reactive.effect\n    @reactive.event(input.move_tasks)\n    def move_selected_tasks():\n        if not input.selected_tasks():\n            return\n            \n        selected_indices = [int(idx) - 1 for idx in input.selected_tasks()]\n        source_list_id = input.active_list()\n        target_list_id = input.move_to_list()\n        \n        current_data = lists_data.get().copy()\n        source_list = current_data[source_list_id]\n        target_list = current_data[target_list_id]\n        \n        # Get tasks and descriptions to move\n        tasks_to_move = [source_list[\"tasks\"][i] for i in selected_indices]\n        descriptions_to_move = [source_list[\"descriptions\"][i] for i in selected_indices]\n        \n        # Add to target list\n        target_list[\"tasks\"].extend(tasks_to_move)\n        target_list[\"descriptions\"].extend(descriptions_to_move)\n        \n        # Remove from source list (in reverse order to maintain indices)\n        for i in sorted(selected_indices, reverse=True):\n            source_list[\"tasks\"].pop(i)\n            source_list[\"descriptions\"].pop(i)\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)  # Add this line\n\n    @reactive.effect\n    @reactive.event(input.start_edit)\n    def start_editing():\n        editing.set(True)\n\n    @reactive.effect\n    @reactive.event(input.cancel_edit)\n    def cancel_editing():\n        editing.set(False)\n\n    @reactive.effect\n    @reactive.event(input.save_edit)\n    def save_edit():\n        if not input.selected_tasks():\n            return\n            \n        task_idx = int(input.selected_tasks()[0]) - 1\n        current_data = lists_data.get().copy()\n        current_list = current_data[input.active_list()]\n        \n        current_list[\"tasks\"][task_idx] = input.edit_task()\n        current_list[\"descriptions\"][task_idx] = input.edit_description()\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)  # Add this line\n        editing.set(False)\n\n    # Add a reactive value for GitHub save status\n    github_status = reactive.value(\"\")\n\n  \n    @render.text\n    def github_status_output():\n        return github_status.get()\n\n    @reactive.effect\n    @reactive.event(input.move_up)\n    def move_task_up():\n        if not input.selected_tasks() or len(input.selected_tasks()) != 1:\n            return\n            \n        task_idx = int(input.selected_tasks()[0]) - 1\n        if task_idx <= 0:  # Can't move up if already at top\n            return\n            \n        current_data = lists_data.get().copy()\n        current_list = current_data[input.active_list()]\n        \n        # Swap tasks\n        current_list[\"tasks\"][task_idx], current_list[\"tasks\"][task_idx-1] = \\\n            current_list[\"tasks\"][task_idx-1], current_list[\"tasks\"][task_idx]\n        \n        # Swap descriptions\n        current_list[\"descriptions\"][task_idx], current_list[\"descriptions\"][task_idx-1] = \\\n            current_list[\"descriptions\"][task_idx-1], current_list[\"descriptions\"][task_idx]\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)  # Add this line\n        \n        # Update the selection to follow the moved task\n        ui.update_checkbox_group(\n            \"selected_tasks\",\n            selected=[str(task_idx)]  # Index is 0-based, but UI is 1-based\n        )\n\n    @reactive.effect\n    @reactive.event(input.move_down)\n    def move_task_down():\n        if not input.selected_tasks() or len(input.selected_tasks()) != 1:\n            return\n            \n        task_idx = int(input.selected_tasks()[0]) - 1\n        current_data = lists_data.get().copy()\n        current_list = current_data[input.active_list()]\n        \n        if task_idx >= len(current_list[\"tasks\"]) - 1:  # Can't move down if already at bottom\n            return\n            \n        # Swap tasks\n        current_list[\"tasks\"][task_idx], current_list[\"tasks\"][task_idx+1] = \\\n            current_list[\"tasks\"][task_idx+1], current_list[\"tasks\"][task_idx]\n        \n        # Swap descriptions\n        current_list[\"descriptions\"][task_idx], current_list[\"descriptions\"][task_idx+1] = \\\n            current_list[\"descriptions\"][task_idx+1], current_list[\"descriptions\"][task_idx]\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)  # Add this line\n        \n        # Update the selection to follow the moved task\n        ui.update_checkbox_group(\n            \"selected_tasks\",\n            selected=[str(task_idx + 2)]  # Index is 0-based, but UI is 1-based\n        )    \n    \n    @reactive.effect\n    @reactive.event(input.delete_task)\n    def delete_task():\n        if not input.selected_tasks():\n            return\n            \n        selected_indices = [int(idx) - 1 for idx in input.selected_tasks()]\n        current_data = lists_data.get().copy()\n        current_list = current_data[input.active_list()]\n        \n        # Remove tasks and descriptions in reverse order to maintain correct indices\n        for idx in sorted(selected_indices, reverse=True):\n            current_list[\"tasks\"].pop(idx)\n            current_list[\"descriptions\"].pop(idx)\n        \n        lists_data.set(current_data)\n        changes_unsaved.set(True)    \n   \n    \n    @reactive.effect\n    @reactive.event(lists_data, input.autosave_enabled)\n    def auto_save():\n        # Check online status first\n        is_online.set(check_online_status())\n        \n        # If autosave was just disabled but there are no actual changes,\n        # make sure changes_unsaved is False\n        if not input.autosave_enabled() and not changes_unsaved.get():\n            return\n    \n        # If there are no changes, nothing to do\n        if not changes_unsaved.get():\n            return\n    \n        # If autosave is disabled, keep existing unsaved state\n        if not input.autosave_enabled():\n            return\n    \n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in GitHub credentials to enable auto-save\")\n            return\n    \n        # If we're offline, queue the changes\n        if not is_online.get():\n            if changes_unsaved.get():\n                github_status.set(\"\u26a0\ufe0f Changes pending - Currently offline\")\n                # Store the current state\n                pending_changes.set(pending_changes.get() + [lists_data.get()])\n            return\n\n        # Online save logic continues as before...\n        path = \"ToDoList.txt\"\n        try:\n            # Prepare the data\n            data = lists_data.get()\n            formatted_data = \"\"\n            for list_id, list_name in LIST_NAMES.items():\n                formatted_data += f\"=== {list_name} ===\\n\"\n                list_content = data[list_id]\n                for task, desc in zip(list_content[\"tasks\"], list_content[\"descriptions\"]):\n                    formatted_data += f\"- {task}\\n\"\n                    if desc.strip():\n                        formatted_data += f\"  |{desc}\\n\"\n                formatted_data += \"\\n\"\n\n            # GitHub API endpoint\n            repo = input.github_repo()\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n\n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n\n            # Check if file exists\n            try:\n                response = requests.get(url, headers=headers)\n                sha = response.json()[\"sha\"] if response.status_code == 200 else None\n            except:\n                sha = None\n\n            # Prepare the content\n            content = base64.b64encode(formatted_data.encode()).decode()\n\n            # Prepare the data for the API request\n            data = {\n                \"message\": \"Auto-update task lists\",\n                \"content\": content,\n            }\n            if sha:\n                data[\"sha\"] = sha\n\n            # Make the API request\n            response = requests.put(url, headers=headers, json=data)\n\n            if response.status_code in [200, 201]:\n                github_status.set(\"\u2713 Changes saved automatically\")\n            else:\n                github_status.set(f\"\u274c Error auto-saving: {response.status_code}\")\n\n        except requests.RequestException as e:\n            github_status.set(\"\u26a0\ufe0f Changes pending - Network error\")\n        except Exception as e:\n            github_status.set(f\"\u274c Error auto-saving: {str(e)}\")\n\n\n\n    @reactive.effect\n    def handle_online_status():\n        # Periodically check online status\n        current_online_status = check_online_status()\n        is_online.set(current_online_status)\n        \n        # If we just came back online and have pending changes\n        if current_online_status and pending_changes.get():\n            try:\n                # Process pending changes\n                if input.autosave_enabled():\n                    # Trigger a save with the latest state\n                    lists_data.set(pending_changes.get()[-1])  # Use most recent change\n                    pending_changes.set([])  # Clear the queue\n                    github_status.set(\"\u2713 Syncing changes after coming back online...\")\n            except Exception as e:\n                github_status.set(f\"\u274c Error syncing changes: {str(e)}\")\n    \n\n    @reactive.effect\n    @reactive.event(input.quick_save)\n    def handle_quick_save():\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in GitHub credentials in the sidebar first\")\n            return\n\n        path = \"ToDoList.txt\"\n        try:\n            # Prepare the data\n            data = lists_data.get()\n            formatted_data = \"\"\n            for list_id, list_name in LIST_NAMES.items():\n                formatted_data += f\"=== {list_name} ===\\n\"\n                list_content = data[list_id]\n                for task, desc in zip(list_content[\"tasks\"], list_content[\"descriptions\"]):\n                    formatted_data += f\"- {task}\\n\"\n                    if desc.strip():\n                        formatted_data += f\"  |{desc}\\n\"\n                formatted_data += \"\\n\"\n\n            # GitHub API endpoint\n            repo = input.github_repo()\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n\n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n\n            # Check if file exists\n            try:\n                response = requests.get(url, headers=headers)\n                if response.status_code == 200:\n                    # File exists, get the SHA\n                    sha = response.json()[\"sha\"]\n                else:\n                    sha = None\n            except:\n                sha = None\n\n            # Prepare the content\n            content = base64.b64encode(formatted_data.encode()).decode()\n\n            # Prepare the data for the API request\n            data = {\n                \"message\": \"Update task lists\",\n                \"content\": content,\n            }\n            if sha:\n                data[\"sha\"] = sha\n\n            # Make the API request\n            response = requests.put(url, headers=headers, json=data)\n\n            if response.status_code in [200, 201]:\n                github_status.set(\"Successfully saved to GitHub!\")\n                changes_unsaved.set(False)\n            else:\n                github_status.set(f\"Error saving to GitHub: {response.status_code}\")\n\n        except Exception as e:\n            github_status.set(f\"Error: {str(e)}\")\n\n    @reactive.effect\n    @reactive.event(input.save_github)\n    def save_to_github():\n        path= \"ToDoList.txt\"\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in all GitHub fields\")\n            return\n    \n        try:\n            # Prepare the data\n            data = lists_data.get()\n            formatted_data = \"\"\n            for list_id, list_name in LIST_NAMES.items():\n                formatted_data += f\"=== {list_name} ===\\n\"\n                list_content = data[list_id]\n                for task, desc in zip(list_content[\"tasks\"], list_content[\"descriptions\"]):\n                    formatted_data += f\"- {task}\\n\"\n                    if desc.strip():\n                        formatted_data += f\"  |{desc}\\n\"\n                formatted_data += \"\\n\"\n    \n            # GitHub API endpoint\n            repo = input.github_repo()\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n    \n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n    \n            # Check if file exists\n            try:\n                response = requests.get(url, headers=headers)\n                sha = response.json()[\"sha\"] if response.status_code == 200 else None\n            except:\n                sha = None\n    \n            # Prepare the content\n            content = base64.b64encode(formatted_data.encode()).decode()\n    \n            # Prepare the data for the API request\n            data = {\n                \"message\": \"Update task lists\",\n                \"content\": content,\n            }\n            if sha:\n                data[\"sha\"] = sha\n    \n            # Make the API request\n            response = requests.put(url, headers=headers, json=data)\n    \n            if response.status_code in [200, 201]:\n                github_status.set(\"Successfully saved to GitHub!\")\n                changes_unsaved.set(False)  # Reset the unsaved changes flag\n            else:\n                github_status.set(f\"Error saving to GitHub: {response.status_code}\")\n    \n        except Exception as e:\n            github_status.set(f\"Error: {str(e)}\")\n        \n    \n    \n    \n    \n    \n    \n    \n\n\n\n\n    \n    def load_list_names_from_github():\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in GitHub credentials to load list names\")\n            return False\n    \n        try:\n            # GitHub API endpoint\n            repo = input.github_repo()\n            path = \"ToDoListNames.txt\"\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n    \n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n    \n            # Get the file content\n            response = requests.get(url, headers=headers)\n            \n            if response.status_code == 404:\n                # File doesn't exist yet, this is okay\n                github_status.set(\"No saved list names found, using defaults\")\n                return True\n            elif response.status_code == 200:\n                # Decode content from base64\n                content = base64.b64decode(response.json()[\"content\"]).decode()\n                \n                # Parse the content and update LIST_NAMES\n                for line in content.strip().split('\\n'):\n                    if ':' in line:\n                        list_id, name = line.split(':', 1)\n                        if list_id in LIST_NAMES:\n                            LIST_NAMES[list_id] = name\n    \n                # Update UI elements\n                ui.update_radio_buttons(\n                    \"active_list\",\n                    choices=LIST_NAMES\n                )\n                ui.update_checkbox_group(\n                    \"display_lists\",\n                    choices=LIST_NAMES,\n                    selected=input.display_lists()\n                )\n                \n                github_status.set(\"Successfully loaded list names from GitHub!\")\n                return True\n            else:\n                github_status.set(f\"Error loading list names from GitHub: {response.status_code}\")\n                return False\n    \n        except Exception as e:\n            github_status.set(f\"Error loading list names: {str(e)}\")\n            return False    \n\n    @reactive.effect\n    @reactive.event(input.load_github)      \n    def load_from_github():        \n        # First load the list names\n        if not load_list_names_from_github():\n            return\n                \n        path = \"ToDoList.txt\"\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in all GitHub fields\")\n            return\n\n        try:\n            # GitHub API endpoint\n            repo = input.github_repo()\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n\n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n\n            # Get the file content\n            response = requests.get(url, headers=headers)\n            \n            if response.status_code == 200:\n                # Decode content from base64\n                content = base64.b64decode(response.json()[\"content\"]).decode()\n                \n                # Parse the content\n                current_list_id = None\n                new_data = {list_id: {\"tasks\": [], \"descriptions\": []} \n                        for list_id in LIST_NAMES.keys()}\n                \n                lines = [line.rstrip() for line in content.split('\\n')]\n                i = 0\n                while i < len(lines):\n                    line = lines[i]\n                    if not line:\n                        i += 1\n                        continue\n                        \n                    # Check if this is a list header\n                    if line.startswith('===') and line.endswith('==='):\n                        list_name = line.strip('= ')\n                        # Find the list_id for this list_name\n                        current_list_id = next(\n                            (k for k, v in LIST_NAMES.items() if v == list_name),\n                            None\n                        )\n                    # Check if this is a task\n                    elif line.startswith('- ') and current_list_id:\n                        task = line[2:]  # Remove the '- ' prefix\n                        new_data[current_list_id][\"tasks\"].append(task)\n                        \n                        # Look ahead for description\n                        desc = \"\"\n                        if i + 1 < len(lines):\n                            next_line = lines[i + 1]\n                            if next_line.startswith('  |'):\n                                desc = next_line[3:].strip()  # Remove '  |' prefix\n                                i += 1  # Skip the description line\n                        new_data[current_list_id][\"descriptions\"].append(desc)\n                    \n                    i += 1\n\n                # Update the lists_data\n                lists_data.set(new_data)\n                github_status.set(\"Successfully loaded from GitHub!\")\n            else:\n                github_status.set(f\"Error loading from GitHub: {response.status_code}\")\n\n        except Exception as e:\n            github_status.set(f\"Error loading: {str(e)}\")\n \n    editing_names = reactive.value(False)\n    \n    \n    @render.ui\n    def list_name_controls():\n        if not editing_names.get():\n            return ui.div()\n            \n        inputs = []\n        for list_id, current_name in LIST_NAMES.items():\n            inputs.extend([\n                ui.input_text(\n                    f\"name_{list_id}\",\n                    f\"Name for {list_id}:\",\n                    value=current_name\n                ),\n                ui.br()\n            ])\n        \n        return ui.div(\n            ui.card(\n                *inputs,\n                ui.div(\n                    ui.input_action_button(\n                        \"save_list_names\", \n                        \"Save Names\", \n                        class_=\"btn-success\"\n                    ),\n                    ui.input_action_button(\n                        \"cancel_list_names\", \n                        \"Cancel\", \n                        class_=\"btn-secondary\"\n                    ),\n                    style=\"display: flex; gap: 10px;\"\n                )\n            )\n        )\n\n    @reactive.effect\n    @reactive.event(input.edit_list_names)\n    def start_editing_names():\n        editing_names.set(True)\n\n    @reactive.effect\n    @reactive.event(input.cancel_list_names)\n    def cancel_editing_names():\n        editing_names.set(False)\n\n    @reactive.effect\n    @reactive.event(input.save_list_names)\n    def save_list_names():\n        # Update the LIST_NAMES dictionary with new values\n        for list_id in LIST_NAMES.keys():\n            LIST_NAMES[list_id] = getattr(input, f\"name_{list_id}\")()\n        \n        # Update any UI elements that depend on list names\n        ui.update_radio_buttons(\n            \"active_list\",\n            choices=LIST_NAMES\n        )\n        ui.update_checkbox_group(\n            \"display_lists\",\n            choices=LIST_NAMES,\n            selected=input.display_lists()\n        )\n        \n        # Save to GitHub if credentials are available\n        save_list_names_to_github()\n        \n        editing_names.set(False)\n        changes_unsaved.set(True)\n\n    def save_list_names_to_github():\n        if not input.github_token() or not input.github_repo():\n            github_status.set(\"Please fill in GitHub credentials to save list names\")\n            return False\n\n        try:\n            # GitHub API endpoint\n            repo = input.github_repo()\n            path = \"ToDoListNames.txt\"\n            url = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n\n            # Headers for authentication\n            headers = {\n                \"Authorization\": f\"token {input.github_token()}\",\n                \"Accept\": \"application/vnd.github.v3+json\"\n            }\n\n            # Format the list names data\n            formatted_data = \"\\n\".join([f\"{list_id}:{name}\" for list_id, name in LIST_NAMES.items()])\n            content = base64.b64encode(formatted_data.encode()).decode()\n\n            # Check if file exists\n            try:\n                response = requests.get(url, headers=headers)\n                sha = response.json()[\"sha\"] if response.status_code == 200 else None\n            except:\n                sha = None\n\n            # Prepare the data for the API request\n            data = {\n                \"message\": \"Update list names\",\n                \"content\": content,\n            }\n            if sha:\n                data[\"sha\"] = sha\n\n            # Make the API request\n            response = requests.put(url, headers=headers, json=data)\n\n            if response.status_code in [200, 201]:\n                github_status.set(\"Successfully saved list names to GitHub!\")\n                return True\n            else:\n                github_status.set(f\"Error saving list names to GitHub: {response.status_code}\")\n                return False\n\n        except Exception as e:\n            github_status.set(f\"Error saving list names: {str(e)}\")\n            return False\n\n   \n    @render.ui\n    def manual_save_button():\n        if not input.autosave_enabled() and changes_unsaved.get():\n            return ui.input_action_button(\n                \"save_github\",  # Changed from manual_save to save_github\n                \"Save Changes to GitHub\",\n                class_=\"btn-success\"\n            )\n        return ui.div()\n    \n   \n    @render.text\n    def unsaved_changes_alert():\n        if not input.autosave_enabled() and changes_unsaved.get():\n            return \"\u26a0\ufe0f You have unsaved changes\"\n        return \"\"\n    \n    \napp = App(app_ui, server)\n", "type": "text"}, {"name": "README.md", "content": "# ToDo\n\n# shiny4Python\nCreate a shiny for Python app.  You can create both a `site` or full app based on `FastAPI`.\n\nIn these lines we:\n- Install `shiny` & `shinylive`\n- Create a Hello world app\n- Run the [app](https://shiny.rstudio.com/py/docs/deploy.html) based on the `FastAPI`\n- Create as a [static website](https://shiny.rstudio.com/py/docs/shinylive.html) with `WebAssembly`\n\n```\npip install shiny\npip install shinylive\nshiny create .\nshiny run \nshinylive export . docs\n```\n\n`Note:` We output the website to `docs` to host on a Github Page\n\n\n![image](https://user-images.githubusercontent.com/33904170/215349262-68b36efa-ceff-40ea-ae80-052303a7258b.png)\n", "type": "text"}]